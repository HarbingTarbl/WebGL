<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title></title>
<title>WebGL</title>
<script type="text/javascript" src="gl-matrix.js"></script>
<script type="x-shader/x-vertex" id="vsm-shadow-vs">
    attribute vec3 vPosition;

    varying highp float fDepth;

    uniform mat4 uProjectionMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;

    uniform highp float uDepthBias;

    highp float hermite(const float minV, const float maxV, highp float v)
    {
        return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
    }

    void main()
    {
        vec4 p = vec4(vPosition, 1.0);
        p = uViewMatrix * uModelMatrix * p;
        fDepth = hermite(1.0, 30.0, p.z * -1.0);

        fDepth += uDepthBias;

        gl_Position = uProjectionMatrix * p;
    }
</script>
<script type="x-shader/x-fragment" id="vsm-shadow-fs">

    #extension GL_OES_standard_derivatives : enable
    precision highp float;

    varying highp float fDepth;


    void main()
    {
        vec2 dFdepth = vec2(dFdx(fDepth), dFdy(fDepth));

        gl_FragColor = vec4(fDepth, fDepth * fDepth + 0.25 * dot(dFdepth, dFdepth), 0, 1);

    }
</script>
<script type="x-shader/x-vertex" id="vsm-composite-vs">
    attribute vec4 vPosition;

    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    void main()
    {
        fNDC = vPosition.xy;
        fTex = fNDC * 0.5 + 0.5;

        gl_Position = vPosition;
    }

</script>

<script type="x-shader/x-fragment" id="vsm-composite-fs">
    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    void main()
    {
        gl_FragColor = vec4(1);
    }

</script>
<script type="x-shader/x-fragment" id="diffuse-fs">
        precision highp float;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;

        uniform sampler2D sVarianceTexture;
        uniform mat4 uVarianceViewMatrix;
        uniform mat4 uVarianceProjectionMatrix;
        uniform highp float uMinVariance;
        uniform highp float uLightBleed;

        highp float hermite(const highp float minV, const highp float maxV, highp float v)
        {   
            return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
        }

       
        void main()
        {
            vec4 variancePoint = uVarianceViewMatrix * vec4(fWorld, 1);
            highp float lightZ = hermite(1.0, 30.0, variancePoint.z * -1.0); //Linear Z from Light
            variancePoint = uVarianceProjectionMatrix * variancePoint;
            vec2 varianceTex = (variancePoint.xy * 0.5 + 0.5);
            vec2 moments = texture2D(sVarianceTexture, varianceTex).rg; //Linear Z from Light w/ depth

            float variance = moments.y - moments.x * moments.x;
            variance = max(variance, uMinVariance);
            float delta = lightZ - moments.x;
            float coverage = 1.0;

            if(delta > 0.0)
            {
                coverage = variance / (variance + delta * delta);
                coverage = hermite(uLightBleed, 1.0, coverage);
            }


            gl_FragColor.rgb = normalize(fNormal) * 0.5 + 0.5;
            gl_FragColor.rgb *= max(coverage, 0.3);
            //gl_FragColor.rgb = vec3(abs(delta));
        }

</script>
<script type="x-shader/x-vertex" id="diffuse-vs">
        attribute vec3 vPosition;
        attribute vec3 vNormal;

        uniform mat4 uCameraMatrix;
        uniform mat4 uModelMatrix;
        uniform mat3 uNormalMatrix;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;

        void main()
        {
            fNormal = uNormalMatrix * vNormal;
            gl_Position = uModelMatrix * vec4(vPosition, 1.0);
            fWorld = gl_Position.xyz;
            gl_Position = uCameraMatrix * gl_Position;
        }


</script>
<script type="text/javascript">
    "use strict";

function Quad() {
    var vertices = new Float32Array([
        1, 1, 0, 1
        -1, 1, 0, 1,
        1, -1, 0, 1,
        -1, -1, 0, 1
    ]);

    this.vertexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);

    this.draw = function() {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
}

function Cube() {
    var vertices = new Float32Array([
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1
    ]);

    var normals = new Float32Array([
        -1, -1, 1,
        1, -1, 1,
        1, 1, 1,
        -1, 1, 1,
        -1, -1, -1,
        1, -1, -1,
        1, 1, -1,
        -1, 1, -1
    ]);

    var indices = new Uint8Array([
        0, 1, 2, 2, 3, 0,
        3, 2, 6, 6, 7, 3,
        7, 6, 5, 5, 4, 7,
        4, 0, 3, 3, 7, 4,
        0, 1, 5, 5, 4, 0,
        1, 5, 6, 6, 2, 1
    ]);

    this.vertexBuffer = gl.createBuffer();
    this.normalBuffer = gl.createBuffer();
    this.elementBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);

    this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);

        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_BYTE, 0);
    }
}

function Plane() {
    var vertices = new Float32Array([
        -1, 0, 1,
        1, 0, 1,
        -1, 0, -1,
        1, 0, -1,
    ]);

    var normals = new Float32Array([
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
    ]);

    this.vertexBuffer = gl.createBuffer();
    this.normalsBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);

    this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
}

function Instance(geo, transform) {
    this.modelMatrix = transform;
    this.fixNormal = true;
    this.geo = geo;

    this.normalMatrix = function() {
        if(this.fixNormal) {
            this._normalMatrix = mat3.fromMat4(mat3.create(), this.modelMatrix);
            var t = mat3.create();
            mat3.transpose(t, this._normalMatrix);
            mat3.invert(this._normalMatrix, t);


            this.fixNormal = false;
        }
        return this._normalMatrix;
    };

    this.translate = function(x) {
        this.fixNormal = true;
        mat4.translate(this.modelMatrix, this.modelMatrix, x);
    };

    this.scale = function(x) {
        this.fixNormal = true;
        mat4.scale(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateX = function(x) { 
        this.fixNormal = true;
        mat4.rotateX(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateY = function(x) {
        this.fixNormal = true;
        mat4.rotateY(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateZ = function(x) {
        this.fixNormal = true;
        mat4.rotateZ(this.modelMatrix, this.modelMatrix, x);
    }
}

function GaussianBlurPass(width, height, radius, texformat, textype) {
    this.kernelRadius = radius;
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = width;
    this.framebuffer.height = height;
    this.framebuffer.use = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.viewport(0, 0, width, height);
    };

    this.ping = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.ping);
    gl.texImage2D(gl.TEXTURE_2D, 0, texformat, width, height, 0, texformat, textype, null);

    this.pong = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.pong);
    gl.texImage2D(gl.TEXTURE_2D, 0, texformat, width, height, 0, texformat, textype, null);




    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function VarianceShaderPass(width, height, mipmaps) {

    this.projectionMatrix = mat4.create();
    mat4.ortho(this.projectionMatrix, -10, 10, -10, 10, 1, 40);
    this.viewMatrix = mat4.create();
    mat4.lookAt(this.viewMatrix, [-10, 10, -10], [0,0,0], [0,1,0]);
    this.mipmapsEnabled = mipmaps;

    this.shadowProgram = new ShaderProgram(
            {
                vertex: document.getElementById("vsm-shadow-vs").text,
                fragment: document.getElementById("vsm-shadow-fs").text,
                binds: [
                    ["vPosition", 0]
                ]
            });

    this.shadowProgram.use();
    this.shadowProgram.uniform.uViewMatrix = this.viewMatrix;
    this.shadowProgram.uniform.uProjectionMatrix = this.projectionMatrix;
    gl.useProgram(null);


    this.framebufferId = gl.createFramebuffer();
    this.depthTextureId = gl.createTexture();
    this.depthRenderBufferId = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthRenderBufferId);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    gl.bindTexture(gl.TEXTURE_2D, this.depthTextureId);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.FLOAT, null);
    if(this.mipmapsEnabled)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    else
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.generateMipmap(gl.TEXTURE_2D);


    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.depthTextureId, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthRenderBufferId);

    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        gl.deleteTexture(this.depthTextureId);
        gl.deleteFramebuffer(this.framebufferId);
        console.log("Framebuffer incomplete");
        return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);

    this.startShadow = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);
        gl.viewport(0, 0, width, height);
        this.shadowProgram.use();
        this.uniform = this.shadowProgram.uniform;
        this.sampler = this.shadowProgram.sampler;
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.draw = function(inst) {
            this.shadowProgram.uniform.uModelMatrix = inst.modelMatrix;
            inst.geo.draw();
        };

        if(this.mipmapsEnabled) {
            this.finish = function () {
                gl.bindTexture(gl.TEXTURE_2D, this.depthTextureId);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
        }
        else {
            this.finish = function(){};
        }
    };
}

function DiffuseShaderPass(width, height){
    this.diffuseProgram = new ShaderProgram({
        vertex: document.getElementById("diffuse-vs").text,
        fragment: document.getElementById("diffuse-fs").text,
        binds: [
            ["vPosition", 0],
            ["vNormal", 1]
        ]
    });


    this.startDiffuse = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);

        this.diffuseProgram.use();
        this.uniform = this.diffuseProgram.uniform;
        this.sampler = this.diffuseProgram.sampler;

        gl.disable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.draw = function(inst) {
            this.diffuseProgram.uniform.uModelMatrix = inst.modelMatrix;
            this.diffuseProgram.uniform.uNormalMatrix = inst.normalMatrix();
            inst.geo.draw();
        };
    }


}

function createTexture(path) {

}

function ShaderProgram(args) {
    "use strict";
    this.valid = false;

    var vertex = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertex, args.vertex);
    gl.compileShader(vertex);
    if (!gl.getShaderParameter(vertex, gl.COMPILE_STATUS)) {
        console.log("could not compile vertex shader : " + args.vertex + " : " +  gl.getShaderInfoLog(vertex));
        gl.deleteShader(vertex);
        return;
    }

    var fragment = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragment, args.fragment);
    gl.compileShader(fragment);
    if (!gl.getShaderParameter(fragment, gl.COMPILE_STATUS)) {
        console.log("could not compile fragment shader : " + args.fragment + " : " + gl.getShaderInfoLog(fragment));
        gl.deleteShader(vertex);
        gl.deleteShader(fragment);
        return;
    }

    this.program = gl.createProgram();
    gl.attachShader(this.program, vertex);
    gl.attachShader(this.program, fragment);

    if (args.hasOwnProperty("binds")) {
        for (var i in args.binds) {
            var bind = args.binds[i];
            gl.bindAttribLocation(this.program, bind[1], bind[0]);
        }
    }

    gl.linkProgram(this.program);

    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        console.log("could not link program : " + gl.getProgramInfoLog(this.program));
        gl.deleteShader(vertex);
        gl.deleteShader(fragment);
        gl.deleteShader(this.program);
        return;
    }

    gl.deleteShader(vertex);
    gl.deleteShader(fragment);

    this.valid = true;
    var nuniforms = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
    this.uniform = {};
    this.sampler = {};
    var cTeId = 0;

    gl.useProgram(this.program);

    for (var i = 0; i < nuniforms; i++) {
        var uniform = gl.getActiveUniform(this.program, i);
        uniform.location = gl.getUniformLocation(this.program, uniform.name);
  
        switch (uniform.type) {
            case gl.FLOAT_MAT4:
                Object.defineProperty(this.uniform, uniform.name, function(a) {
                    return {
                        set: function(v) {
                            gl.uniformMatrix4fv(a.location, false, v);
                        },
                        get: function() {
                            return "mat4";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT_MAT3:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v) {
                            gl.uniformMatrix3fv(a.location, false, v);
                        },
                        get: function() {
                            return "mat3";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT_MAT2:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v) {
                            gl.uniformMatrix2fv(a.location, false, v);
                        },
                        get: function() {
                            return "mat2";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT_VEC4:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v){
                            gl.uniform4fv(a.location, v);
                        },
                        get: function() {
                            return "vec4";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT_VEC3:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v){
                            gl.uniform3fv(a.location, v);
                        },
                        get: function() {
                            return "vec3";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT_VEC2:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v){
                            gl.uniform2fv(a.location, v);
                        },
                        get: function() {
                            return "vec2";
                        }
                    };
                }(uniform));
                break;
            case gl.FLOAT:
                Object.defineProperty(this.uniform, uniform.name, function(a){
                    return {
                        set: function(v){
                            gl.uniform1f(a.location, v);
                        },
                        get: function() {
                            return "float";
                        }
                    };
                }(uniform));
                break;

            case gl.SAMPLER_2D:
                gl.uniform1i(uniform.location, cTeId);  
                Object.defineProperty(this.sampler, uniform.name, function(a){
                    return {
                        set: function(v){
                            gl.activeTexture(gl.TEXTURE0 + a);
                            gl.bindTexture(gl.TEXTURE_2D, v);
                        },
                        get: function(){
                            return "sampler2D";
                        }
                    };
                }(cTeId++));
                break;
        }
    }

    Object.freeze(this.uniform);
    Object.freeze(this.sampler);

    gl.useProgram(null);

    this.use = function () {
        gl.useProgram(this.program);
    }
}

var gl = null;
var meshes = null;
var textures = null;
var instances = null;
var extensions = null;
var passes = null;


var viewMatrix = mat4.create();
var projectionMatrix = mat4.create();
var cameraMatrix = mat4.create();


function startWGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl", {
            antialias: true,
            stencil: false,
            depth: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        if (!gl) {
            alert("Could not start WebGL")
            return;
        }

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        gl.ext = {};
        gl.ext.texture_float = gl.getExtension("OES_texture_float");
        gl.ext.texture_float_linear = gl.getExtension("OES_texture_float_linear");
        gl.ext.standard_derivatives = gl.getExtension("OES_standard_derivatives");


    } catch (excp) {
        alert("Could not start WebGL : " + excp);
    }

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    meshes = {
        cube: new Cube(),
        plane: new Plane(),
        quad: new Quad(),
    };

    instances = {
        cube: new Instance(meshes.cube, mat4.create()),
        floor: new Instance(meshes.cube, mat4.create()),
        southwall: new Instance(meshes.cube, mat4.create()),
        westwall: new Instance(meshes.cube, mat4.create()),
        eastwall: new Instance(meshes.cube, mat4.create())
    };


    instances.cube.translate([0,0.5,0]);

    mat4.translate(instances.floor.modelMatrix, instances.floor.modelMatrix, [0, -1, 0]);
    mat4.scale(instances.floor.modelMatrix, instances.floor.modelMatrix, [10, 0.5, 10]);


    mat4.translate(instances.southwall.modelMatrix, instances.southwall.modelMatrix, [0, 1.5, -5]);
    mat4.scale(instances.southwall.modelMatrix, instances.southwall.modelMatrix, [5.5, 2, 0.5]);
    mat4.rotateX(instances.southwall.modelMatrix, instances.southwall.modelMatrix, 3.14 / 2);


    mat4.translate(instances.westwall.modelMatrix, instances.westwall.modelMatrix, [-5, 1.5, 0.25]);
    mat4.scale(instances.westwall.modelMatrix, instances.westwall.modelMatrix, [0.5, 2, 4.75]);
    mat4.rotateZ(instances.westwall.modelMatrix, instances.westwall.modelMatrix, -3.14 / 2);

    mat4.translate(instances.eastwall.modelMatrix, instances.eastwall.modelMatrix, [5, 1.5, 0.25]);
    mat4.scale(instances.eastwall.modelMatrix, instances.eastwall.modelMatrix, [0.5, 2, 4.75]);
    mat4.rotateZ(instances.eastwall.modelMatrix, instances.eastwall.modelMatrix, 3.14 / 2);

    instances.floor.fixNormal = true;
    instances.cube.fixNormal = true;
    instances.eastwall.fixNormal = true;
    instances.westwall.fixNormal = true;
    instances.southwall.fixNormal = true;

    textures = {

    };

    var dist = 1;
    mat4.lookAt(viewMatrix, [10.0 * dist, 10.0 * dist, 10.0 * dist], [0, 0, 0], [0, 1, 0]);
    mat4.perspective(projectionMatrix, 65.0 * 3.14 / 180, gl.viewportWidth / gl.viewportHeight, 1, 40.0);

    mat4.multiply(cameraMatrix, projectionMatrix, viewMatrix);

    passes = {
        shadow: new VarianceShaderPass(512, 512, false),
        diffuse: new DiffuseShaderPass(gl.viewportWidth, gl.viewportHeight),
        gaussianBlur: new GaussianBlurPass(512,512, 10, gl.RGB, gl.FLOAT)
    };

    passes.shadow.startShadow();
    passes.shadow.uniform.uDepthBias = 0.000;

    for(var inst in instances) {
        passes.shadow.draw(instances[inst]);
    }

    passes.shadow.finish();



    passes.diffuse.startDiffuse();
    passes.diffuse.uniform.uCameraMatrix = cameraMatrix;
    passes.diffuse.sampler.sVarianceTexture = passes.shadow.depthTextureId;
    passes.diffuse.uniform.uMinVariance = 0.00005;
    passes.diffuse.uniform.uVarianceViewMatrix = passes.shadow.viewMatrix;
    passes.diffuse.uniform.uVarianceProjectionMatrix = passes.shadow.projectionMatrix;
    passes.diffuse.uniform.uLightBleed = 0.2;

    for (var inst in instances) {
        passes.diffuse.draw(instances[inst]);   
    }
 
 }

</script>
</head>
<body onload="startWGL(document.getElementById('canvas'))">
<canvas id="canvas" width="800" height="600" style="border: none;"></canvas>
</body>
</html>