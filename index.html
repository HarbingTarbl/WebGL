<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title></title>
<title>WebGL</title>
<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="ShaderProgram.js"></script>
<script type="text/javascript" src="FlightCamera.js"></script>
<script type="x-shader/x-vertex" id="vsm-shadow-vs">
    attribute vec3 vPosition;

    varying highp float fDepth;

    uniform mat4 uProjectionMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;

    uniform highp float uDepthBias;

    highp float hermite(const float minV, const float maxV, highp float v)
    {
        return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
    }

    void main()
    {
        vec4 p = vec4(vPosition, 1.0);
        p = uViewMatrix * uModelMatrix * p;
        fDepth = hermite(1.0, 30.0, p.z * -1.0);

        fDepth += uDepthBias;

        gl_Position = uProjectionMatrix * p;
    }
</script>
<script type="x-shader/x-fragment" id="vsm-shadow-fs">

    #extension GL_OES_standard_derivatives : enable
    precision highp float;

    varying highp float fDepth;


    void main()
    {
        vec2 dFdepth = vec2(dFdx(fDepth), dFdy(fDepth));

        gl_FragColor = vec4(fDepth, fDepth * fDepth + 0.25 * dot(dFdepth, dFdepth), fDepth, 1);

    }
</script>
<script type="x-shader/x-vertex" id="gaussblur-vs">
    attribute vec4 vPosition;

    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    void main()
    {
        fNDC = vPosition.xy;
        fTex = fNDC * 0.5 + 0.5;

        gl_Position = vPosition;
    }

</script>

<script type="x-shader/x-fragment" id="gaussblur-fs">
    precision highp float;

    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    uniform vec2 uTexelStride;
    uniform sampler2D sTexture;


    void main()
    {
        vec3 smp = texture2D(sTexture, fTex).rgb;
        vec3 color = vec3(smp.rg * 0.2270270270, smp.b);

        smp = texture2D(sTexture, fTex + 1.3846153846 * uTexelStride).rgb;
        color.rg += smp.rg * 0.3162162162;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex - 1.3846153846 * uTexelStride).rgb;
        color.rg += smp.rg * 0.3162162162;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex + 3.2307692308 * uTexelStride).rgb;
        color.rg += smp.rg * 0.0702702703;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex - 3.2307692308 * uTexelStride).rgb;
        color.rg += smp.rg * 0.0702702703;
        color.b = max(smp.b, color.b);

        gl_FragColor.rgb = color;
    }

</script>
<script type="x-shader/x-fragment" id="diffuse-fs">
        precision highp float;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;
        varying lowp vec4 fColor;

        uniform sampler2D sVarianceTexture;
        uniform mat4 uVarianceViewMatrix;
        uniform mat4 uVarianceProjectionMatrix;
        uniform highp float uMinVariance;
        uniform highp float uLightBleed;
        uniform vec3 uSunDirection;

        highp float hermite(const highp float minV, const highp float maxV, highp float v)
        {   
            return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
        }

       
        void main()
        {
            vec4 variancePoint = uVarianceViewMatrix * vec4(fWorld, 1);
            highp float lightZ = hermite(1.0, 30.0, variancePoint.z * -1.0); //Linear Z from Light
            variancePoint = uVarianceProjectionMatrix * variancePoint;
            vec2 varianceTex = (variancePoint.xy * 0.5 + 0.5);
            vec3 moments = texture2D(sVarianceTexture, varianceTex).rgb; //Linear Z from Light w/ depth

            float variance = moments.y - moments.x * moments.x;
            variance = max(variance, uMinVariance);
            float delta = lightZ - moments.x;
            float coverage = 1.0;
            if(delta > 0.0)
            {
                coverage = variance / (variance + delta * delta);
                coverage = hermite(uLightBleed, 1.0, coverage);
            }
            if(moments.z <= lightZ)
            {
                coverage = 0.0;
            }


            vec3 tNormal = normalize(fNormal);
            float diffuseCoeff = clamp(dot(tNormal, uSunDirection), 0.0, 1.0);



            gl_FragColor = fColor * clamp(diffuseCoeff + 0.1, 0.0, 1.0);
            gl_FragColor.rgb *= max(coverage, 0.15);
            //gl_FragColor.rgb = vec3(abs(delta));
        }

</script>
<script type="x-shader/x-vertex" id="diffuse-vs">
        attribute vec3 vPosition;
        attribute vec3 vNormal;
        attribute vec4 vColor;

        uniform mat4 uCameraMatrix;
        uniform mat4 uModelMatrix;
        uniform mat3 uNormalMatrix;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;
        varying lowp vec4 fColor;

        void main()
        {
            fColor = vColor;
            fNormal = uNormalMatrix * vNormal;
            gl_Position = uModelMatrix * vec4(vPosition, 1.0);
            fWorld = gl_Position.xyz;
            gl_Position = uCameraMatrix * gl_Position;
        }


</script>
<script type="text/javascript">
    "use strict";

function Quad() {
    var vertices = new Float32Array([
        1, 1, 0, 1,
        -1, 1, 0, 1,
        1, -1, 0, 1,
        -1, -1, 0, 1
    ]);

    this.vertexBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);

    this.draw = function() {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };
}

function Cube() {
    var vertices = new Float32Array([
        -1.0, -1.0,  1.0,
        1.0, -1.0,  1.0,
        1.0,  1.0,  1.0,
        -1.0,  1.0,  1.0,
        -1.0, -1.0, -1.0,
        -1.0,  1.0, -1.0,
        1.0,  1.0, -1.0,
        1.0, -1.0, -1.0,
        -1.0,  1.0, -1.0,
        -1.0,  1.0,  1.0,
        1.0,  1.0,  1.0,
        1.0,  1.0, -1.0,
        -1.0, -1.0, -1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0,  1.0,
        -1.0, -1.0,  1.0,
        1.0, -1.0, -1.0,
        1.0,  1.0, -1.0,
        1.0,  1.0,  1.0,
        1.0, -1.0,  1.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0,  1.0,
        -1.0,  1.0,  1.0,
        -1.0,  1.0, -1.0
    ]);

    var normals = new Float32Array([
        0.0,  0.0,  1.0,
        0.0,  0.0,  1.0,
        0.0,  0.0,  1.0,
        0.0,  0.0,  1.0,
        0.0,  0.0, -1.0,
        0.0,  0.0, -1.0,
        0.0,  0.0, -1.0,
        0.0,  0.0, -1.0,
        0.0,  1.0,  0.0,
        0.0,  1.0,  0.0,
        0.0,  1.0,  0.0,
        0.0,  1.0,  0.0,
        0.0, -1.0,  0.0,
        0.0, -1.0,  0.0,
        0.0, -1.0,  0.0,
        0.0, -1.0,  0.0,
        1.0,  0.0,  0.0,
        1.0,  0.0,  0.0,
        1.0,  0.0,  0.0,
        1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
    ]);

    var indices = new Uint8Array([
        0,  1,  2,      0,  2,  3,    // front
        4,  5,  6,      4,  6,  7,    // back
        8,  9,  10,     8,  10, 11,   // top
        12, 13, 14,     12, 14, 15,   // bottom
        16, 17, 18,     16, 18, 19,   // right
        20, 21, 22,     20, 22, 23    // left
    ]);

    this.vertexBuffer = gl.createBuffer();
    this.normalBuffer = gl.createBuffer();
    this.elementBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);

    this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);

        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_BYTE, 0);
    }
}

function Plane() {
    var vertices = new Float32Array([
        -1, 0, 1,
        1, 0, 1,
        -1, 0, -1,
        1, 0, -1,
    ]);

    var normals = new Float32Array([
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
        0, 1, 0,
    ]);

    this.vertexBuffer = gl.createBuffer();
    this.normalsBuffer = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    gl.enableVertexAttribArray(0);
    gl.enableVertexAttribArray(1);

    this.draw = function () {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalsBuffer);
        gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
}

function Instance(geo, transform) {
    this.modelMatrix = transform;
    this.fixNormal = true;
    this.geo = geo;
    this.color = [1,1,1,1];

    this.normalMatrix = function() {
        if(this.fixNormal) {
            this._normalMatrix = mat3.fromMat4(mat3.create(), this.modelMatrix);
            var t = mat3.create();
            mat3.transpose(t, this._normalMatrix);
            mat3.invert(this._normalMatrix, t);


            this.fixNormal = false;
        }
        return this._normalMatrix;
    };

    this.translate = function(x) {
        this.fixNormal = true;
        mat4.translate(this.modelMatrix, this.modelMatrix, x);
    };

    this.scale = function(x) {
        this.fixNormal = true;
        mat4.scale(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateX = function(x) { 
        this.fixNormal = true;
        mat4.rotateX(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateY = function(x) {
        this.fixNormal = true;
        mat4.rotateY(this.modelMatrix, this.modelMatrix, x);
    };

    this.rotateZ = function(x) {
        this.fixNormal = true;
        mat4.rotateZ(this.modelMatrix, this.modelMatrix, x);
    }
}

function GaussianBlurPass(width, height, radius, texformat, textype) {
    this.kernelRadius = radius;
    this.framebuffer = gl.createFramebuffer();
    this.framebuffer.width = width;
    this.framebuffer.height = height;
    this.framebuffer.use = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.viewport(0, 0, width, height);
    };

    var fbF = function() {
        var k = gl.createFramebuffer();
        k.width = width;
        k.height = height;
        k.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, k.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, texformat, width, height, 0, texformat, textype, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);


        gl.bindFramebuffer(gl.FRAMEBUFFER, k);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, k.texture, 0);


        if(gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
            k.use = function() {
                gl.bindFramebuffer(gl.FRAMEBUFFER, k);
                gl.viewport(0, 0, width, height);
            }
        } else {
            k = null;
            globalGLError = true;
            console.log("Invalid Gauss Framebuffer");            
        }


        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return k;
    };

    this.ping = fbF();
    this.pong = fbF();


    var vSource = document.getElementById("gaussblur-vs").text;
    var fSource = document.getElementById("gaussblur-fs").text;

    this.program = new ShaderProgram({
        vertex: vSource,
        fragment: fSource,
        binds: [
            ["vPosition", 0]
        ]
    });

    this.start = function(){
        this.program.use();
        this.uniform = this.program.uniform;
        this.sampler = this.program.sampler;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);

        this.blit = function(a) {
            //WebGL lacks actual framebuffer blits. Code that later.
        };

        this.finish = function() {
            this.uniform = null;
            this.sampler = null;
        };
    }





    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function VarianceShaderPass(width, height, mipmaps) {
    this.width = width;
    this.height = height;

    this.projectionMatrix = mat4.create();
    mat4.ortho(this.projectionMatrix, -10, 10, -10, 10, 1, 40);
    this.viewMatrix = mat4.create();
    mat4.lookAt(this.viewMatrix, sunDir, [0,0,0], [0,1,0]);
    this.mipmapsEnabled = mipmaps;

    this.shadowProgram = new ShaderProgram(
            {
                vertex: document.getElementById("vsm-shadow-vs").text,
                fragment: document.getElementById("vsm-shadow-fs").text,
                binds: [
                    ["vPosition", 0]
                ]
            });

    this.shadowProgram.use();
    this.shadowProgram.uniform.uViewMatrix = this.viewMatrix;
    this.shadowProgram.uniform.uProjectionMatrix = this.projectionMatrix;
    gl.useProgram(null);


    this.framebufferId = gl.createFramebuffer();
    this.depthTextureId = gl.createTexture();
    this.depthRenderBufferId = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthRenderBufferId);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

    gl.bindTexture(gl.TEXTURE_2D, this.depthTextureId);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.FLOAT, null);
    if(this.mipmapsEnabled)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    else
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.generateMipmap(gl.TEXTURE_2D);


    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.depthTextureId, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthRenderBufferId);

    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        gl.deleteTexture(this.depthTextureId);
        gl.deleteFramebuffer(this.framebufferId);
        console.log("Framebuffer incomplete");
        globalGLError = true;
        return;
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);

    this.startShadow = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebufferId);
        gl.viewport(0, 0, width, height);
        this.shadowProgram.use();
        this.uniform = this.shadowProgram.uniform;
        this.sampler = this.shadowProgram.sampler;
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.draw = function(inst) {
            this.shadowProgram.uniform.uModelMatrix = inst.modelMatrix;
            inst.geo.draw();
        };

        if(this.mipmapsEnabled) {
            this.finish = function () {
                gl.bindTexture(gl.TEXTURE_2D, this.depthTextureId);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
        }
        else {
            this.finish = function(){};
        }
    };
}

function DiffuseShaderPass(width, height){
    this.diffuseProgram = new ShaderProgram({
        vertex: document.getElementById("diffuse-vs").text,
        fragment: document.getElementById("diffuse-fs").text,
        binds: [
            ["vPosition", 0],
            ["vNormal", 1],
            ["vColor", 2]
        ]
    });


    this.startDiffuse = function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, width, height);

        this.diffuseProgram.use();
        this.uniform = this.diffuseProgram.uniform;
        this.sampler = this.diffuseProgram.sampler;

        gl.disable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        this.draw = function(inst) {
            this.diffuseProgram.uniform.uModelMatrix = inst.modelMatrix;
            this.diffuseProgram.uniform.uNormalMatrix = inst.normalMatrix();
            gl.vertexAttrib4fv(2, inst.color);
            inst.geo.draw();

        };
    }


}

function createTexture(path) {

}

var gl = null;
var meshes = null;
var textures = null;
var instances = null;
var extensions = null;
var passes = null;
var settings = {};
var globalGLError = false;


var viewMatrix = mat4.create();
var projectionMatrix = mat4.create();
var cameraMatrix = mat4.create();


function startWGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl", {
            antialias: true,
            stencil: false,
            depth: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        if (!gl) {
            alert("Could not start WebGL")
            return;
        }

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        gl.ext = {};
        gl.ext.texture_float = gl.getExtension("OES_texture_float");
        gl.ext.texture_float_linear = gl.getExtension("OES_texture_float_linear");
        gl.ext.standard_derivatives = gl.getExtension("OES_standard_derivatives");


    } catch (excp) {
        alert("Could not start WebGL : " + excp);
    }

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    meshes = {
        cube: new Cube(),
        plane: new Plane(),
        quad: new Quad(),
    };

    instances = {
        cube: new Instance(meshes.cube, mat4.create()),
        floor: new Instance(meshes.cube, mat4.create()),
        southwall: new Instance(meshes.cube, mat4.create()),
        westwall: new Instance(meshes.cube, mat4.create()),
        eastwall: new Instance(meshes.cube, mat4.create())
    };


    instances.cube.translate([0,0.5,0]);
    instances.cube.color = [1,0,0,1];


    instances.floor.translate([0, -1, 0]);
    instances.floor.scale([10,0.5,10]);
    instances.floor.color = [1,1,1,1];

    instances.southwall.translate([0, 1.0, -5]);
    instances.southwall.scale([5.5, 2, 0.5]);
    instances.southwall.rotateX(3.14 / 2);
    instances.southwall.color = [0.3, 0.6, 0.8, 1];

    instances.westwall.translate([-5, 1.0, 0.0]);
    instances.westwall.scale([0.5, 2, 4.75]);
    instances.westwall.rotateZ(-3.14 / 2);
    instances.westwall.color = [0.3, 0.6, 0.8, 1];


    instances.eastwall.translate([5, 1.0, 0.0]);
    instances.eastwall.scale([0.5, 2, 4.75])    
    instances.eastwall.rotateZ(3.14 / 2);
    instances.eastwall.color = [0.8, 0.6, 0.8, 1];


    instances.floor.fixNormal = true;
    instances.cube.fixNormal = true;
    instances.eastwall.fixNormal = true;
    instances.westwall.fixNormal = true;
    instances.southwall.fixNormal = true;

    textures = {

    };

    var dist = 0.8;
    mat4.lookAt(viewMatrix, [10.0 * dist, 10.0 * dist, 10.0 * dist], [0, 0, 0], [0, 1, 0]);
    mat4.perspective(projectionMatrix, 65.0 * 3.14 / 180, gl.viewportWidth / gl.viewportHeight, 1, 40.0);

    mat4.multiply(cameraMatrix, projectionMatrix, viewMatrix);

    var shadowMapWidth = 1024;
    var shadowMapHeight = 1024;

    passes = {
        shadow: new VarianceShaderPass(shadowMapWidth, shadowMapHeight, false),
        diffuse: new DiffuseShaderPass(gl.viewportWidth, gl.viewportHeight),
        gaussianBlur: new GaussianBlurPass(shadowMapWidth,shadowMapHeight, 10, gl.RGB, gl.FLOAT)
    }; 

    drawScene();
 }

 var sunDir = [-10, 10, -10];

 function drawScene() {
    if(globalGLError)
        return;

    requestAnimationFrame(drawScene);

    vec3.transformMat4(sunDir, sunDir, mat4.rotateY(mat4.create(), mat4.create(), 0.01));

    passes.shadow.startShadow();
    mat4.lookAt(passes.shadow.viewMatrix, sunDir, [0,0,0], [0,1,0]);
    passes.shadow.uniform.uViewMatrix = passes.shadow.viewMatrix;
    passes.shadow.uniform.uDepthBias = document.getElementById("uDepthBias").value;
    
    for(var inst in instances) {
        passes.shadow.draw(instances[inst]);
    }

    passes.shadow.finish();


    passes.gaussianBlur.start();
    passes.gaussianBlur.ping.use();
    passes.gaussianBlur.uniform.uTexelStride = [1.0 / passes.shadow.width, 0.0];
    passes.gaussianBlur.sampler.sTexture = passes.shadow.depthTextureId;
    meshes.quad.draw();

    passes.gaussianBlur.pong.use();
    passes.gaussianBlur.uniform.uTexelStride = [0.0, 1.0 / passes.shadow.height];
    passes.gaussianBlur.sampler.sTexture = passes.gaussianBlur.ping.texture;
    meshes.quad.draw();

    passes.gaussianBlur.ping.use();
    passes.gaussianBlur.uniform.uTexelStride = [1.0 / passes.shadow.width, 0.0];
    passes.gaussianBlur.sampler.sTexture = passes.shadow.depthTextureId;
    meshes.quad.draw();

    passes.gaussianBlur.pong.use();
    passes.gaussianBlur.uniform.uTexelStride = [0.0, 1.0 / passes.shadow.height];
    passes.gaussianBlur.sampler.sTexture = passes.gaussianBlur.ping.texture;
    meshes.quad.draw();


    passes.diffuse.startDiffuse();
    passes.diffuse.uniform.uCameraMatrix = cameraMatrix;
    passes.diffuse.sampler.sVarianceTexture = passes.gaussianBlur.pong.texture;
    passes.diffuse.uniform.uMinVariance = document.getElementById("uMinVariance").value;
    passes.diffuse.uniform.uVarianceViewMatrix = passes.shadow.viewMatrix;
    passes.diffuse.uniform.uVarianceProjectionMatrix = passes.shadow.projectionMatrix;
    passes.diffuse.uniform.uLightBleed = document.getElementById("uLightBleed").value;




    var  v = vec3.create();
    vec3.normalize(v, sunDir);
    passes.diffuse.uniform.uSunDirection = v;

    for (var inst in instances) {
        passes.diffuse.draw(instances[inst]);   
    }
 }

</script>
</head>
<body onload="startWGL(document.getElementById('canvas'))">
<canvas id="canvas" width="800" height="600" style="border: none; float:left;"></canvas>
<table style="float:right; width:600px;">
<tr>
<td>
<label>Min Variance</label>
<input label="Min Variance" type="range" step="0.0001" min="-0.01" max="0.01" id="uMinVariance" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
<tr>
<td>
<label>Light Bleeding</label>
<input label="Light Bleeding" type="range" step="0.001" min="0" max="1" id="uLightBleed" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
<tr>
<td>
<label>Depth Bias</label>
<input label="Depth Bias" type="range" step="0.001", min="-0.1" max="0.1" id="uDepthBias" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
</table>

</body>
</html>