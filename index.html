<!DOCTYPE html>
<html>
<head lang="en">
<meta charset="UTF-8">
<title></title>
<title>WebGL</title>
</head>
<body onload="startWGL(document.getElementById('canvas'))">
<canvas id="canvas" width="800" height="600" style="border: none; float:left;"></canvas>
<table style="float:right; width:600px;">
<tr>
<td>
<label>Min Variance</label>
<input label="Min Variance" type="range" step="0.0001" min="-0.01" max="0.01" id="uMinVariance" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
<tr>
<td>
<label>Light Bleeding</label>
<input label="Light Bleeding" type="range" step="0.001" min="0" max="1" id="uLightBleed" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
<tr>
<td>
<label>Depth Bias</label>
<input label="Depth Bias" type="range" step="0.001", min="-0.1" max="0.1" id="uDepthBias" onchange="console.log(this.value)" style="width:600px"/>
</td>
</tr>
</table>

<script type="x-shader/x-vertex" id="shadowmap-adaptive-bias-vs">
    attribute vec3 vPosition;
    varying highp float fDepth;

    uniform mat4 uProjectionMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;

    uniform float uNearZ;
    uniform float uFarZ;

    highp float hermite(const float minV, const float maxV, highp float v)
    {
        return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
    }

    void main()
    {
        vec4 pPos = vec4(vPosition, 1.0);
        pPos = uViewMatrix * uModelMatrix * pPos;
        fDepth = hermite(uNearZ, uFarZ, pPos.z * -1);
        gl_Position = uProjectionMatrix * pPos;
    }

</script>
<script type="x-shader/x-fragment" id="shadowmap-adaptive-bias-fs">
    varying highp float fDepth;



    vec4 EncodeFloatRGBA(float v)
    {
        vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
        enc = frac(enc);
        enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
        return enc;
    }



    void main()
    {
        gl_FragColor = EncodeFloatRGBA(enc);
    }

</script>
<script type="x-shader/x-vertex" id="vsm-shadow-vs">
    attribute vec3 vPosition;

    varying highp float fDepth;

    uniform mat4 uProjectionMatrix;
    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;

    uniform highp float uDepthBias;

    highp float hermite(const float minV, const float maxV, highp float v)
    {
        return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
    }

    void main()
    {
        vec4 p = vec4(vPosition, 1.0);
        p = uViewMatrix * uModelMatrix * p;
        fDepth = hermite(1.0, 30.0, p.z * -1.0);

        fDepth += uDepthBias;

        gl_Position = uProjectionMatrix * p;
    }
</script>
<script type="x-shader/x-fragment" id="vsm-shadow-fs">

    #extension GL_OES_standard_derivatives : enable
    precision highp float;

    varying highp float fDepth;


    void main()
    {
        vec2 dFdepth = vec2(dFdx(fDepth), dFdy(fDepth));

        gl_FragColor = vec4(fDepth, fDepth * fDepth + 0.25 * dot(dFdepth, dFdepth), fDepth, 1);

    }
</script>
<script type="x-shader/x-vertex" id="gaussblur-vs">
    attribute vec4 vPosition;

    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    void main()
    {
        fNDC = vPosition.xy;
        fTex = fNDC * 0.5 + 0.5;

        gl_Position = vPosition;
    }

</script>

<script type="x-shader/x-fragment" id="gaussblur-fs">
    precision highp float;

    varying mediump vec2 fTex;
    varying mediump vec2 fNDC;

    uniform vec2 uTexelStride;
    uniform sampler2D sTexture;


    void main()
    {
        vec3 smp = texture2D(sTexture, fTex).rgb;
        vec3 color = vec3(smp.rg * 0.2270270270, smp.b);

        smp = texture2D(sTexture, fTex + 1.3846153846 * uTexelStride).rgb;
        color.rg += smp.rg * 0.3162162162;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex - 1.3846153846 * uTexelStride).rgb;
        color.rg += smp.rg * 0.3162162162;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex + 3.2307692308 * uTexelStride).rgb;
        color.rg += smp.rg * 0.0702702703;
        color.b = max(smp.b, color.b);
        smp = texture2D(sTexture, fTex - 3.2307692308 * uTexelStride).rgb;
        color.rg += smp.rg * 0.0702702703;
        color.b = max(smp.b, color.b);

        gl_FragColor.rgb = color;
    }

</script>
<script type="x-shader/x-fragment" id="diffuse-fs">
        precision highp float;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;
        varying lowp vec4 fColor;

        uniform sampler2D sVarianceTexture;
        uniform mat4 uVarianceViewMatrix;
        uniform mat4 uVarianceProjectionMatrix;
        uniform highp float uMinVariance;
        uniform highp float uLightBleed;
        uniform vec3 uSunDirection;

        highp float hermite(const highp float minV, const highp float maxV, highp float v)
        {
            return clamp((v - minV) / (maxV - minV), 0.0, 1.0);
        }


        void main()
        {
            vec4 variancePoint = uVarianceViewMatrix * vec4(fWorld, 1);
            highp float lightZ = hermite(1.0, 30.0, variancePoint.z * -1.0); //Linear Z from Light
            variancePoint = uVarianceProjectionMatrix * variancePoint;
            vec2 varianceTex = (variancePoint.xy * 0.5 + 0.5);
            vec3 moments = texture2D(sVarianceTexture, varianceTex).rgb; //Linear Z from Light w/ depth

            float variance = moments.y - moments.x * moments.x;
            variance = max(variance, uMinVariance);
            float delta = lightZ - moments.x;
            float coverage = 1.0;
            if(delta > 0.0)
            {
                coverage = variance / (variance + delta * delta);
                coverage = hermite(uLightBleed, 1.0, coverage);
            }
            if(moments.z <= lightZ)
            {
                coverage = 0.0;
            }


            vec3 tNormal = normalize(fNormal);
            float diffuseCoeff = clamp(dot(tNormal, uSunDirection), 0.0, 1.0);



            gl_FragColor = fColor * clamp(diffuseCoeff + 0.1, 0.0, 1.0);
            gl_FragColor.rgb *= max(coverage, 0.15);
            //gl_FragColor.rgb = vec3(abs(delta));
        }

</script>
<script type="x-shader/x-vertex" id="diffuse-vs">
        attribute vec3 vPosition;
        attribute vec3 vNormal;
        attribute vec4 vColor;

        uniform mat4 uCameraMatrix;
        uniform mat4 uModelMatrix;
        uniform mat3 uNormalMatrix;

        varying highp vec3 fNormal;
        varying highp vec3 fWorld;
        varying lowp vec4 fColor;

        void main()
        {
            fColor = vColor;
            fNormal = uNormalMatrix * vNormal;
            gl_Position = uModelMatrix * vec4(vPosition, 1.0);
            fWorld = gl_Position.xyz;
            gl_Position = uCameraMatrix * gl_Position;
        }


</script>



<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="ShaderProgram.js"></script>
<script type="text/javascript" src="FlightCamera.js"></script>
<script type="text/javascript" src="PrimitiveMeshes.js"></script>
<script type="text/javascript" src="ShadowMapAdaptiveBiasPass.js"></script>
<script type="text/javascript" src="DiffuseColorPass.js"></script>
<script type="text/javascript" src="VarianceShadowPass.js"></script>
<script type="text/javascript" src="GaussianBlurPass.js"></script>

<script type="text/javascript">
"use strict";

var gl = null;
var meshes = null;
var instances = null;
var extensions = null;
var passes = null;
var settings = {};
var globalGLError = false;

var viewMatrix = mat4.create();
var projectionMatrix = mat4.create();
var cameraMatrix = mat4.create();

function startWGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl", {
            antialias: true,
            stencil: false,
            depth: true,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false
        });

        if (!gl) {
            alert("Could not start WebGL")
            return;
        }

        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;

        gl.ext = {};
        gl.ext.texture_float = gl.getExtension("OES_texture_float");
        gl.ext.texture_float_linear = gl.getExtension("OES_texture_float_linear");
        gl.ext.standard_derivatives = gl.getExtension("OES_standard_derivatives");


    } catch (excp) {
        alert("Could not start WebGL : " + excp);
    }

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);

    meshes = {
        cube: new Cube(),
        plane: new Plane(),
        quad: new Quad(),
    };

    instances = {
        cube: new Instance(meshes.cube, mat4.create()),
        floor: new Instance(meshes.cube, mat4.create()),
        southwall: new Instance(meshes.cube, mat4.create()),
        westwall: new Instance(meshes.cube, mat4.create()),
        eastwall: new Instance(meshes.cube, mat4.create())
    };


    instances.cube.translate([0,0.5,0]);
    instances.cube.color = [1,0,0,1];


    instances.floor.translate([0, -1, 0]);
    instances.floor.scale([10,0.5,10]);
    instances.floor.color = [1,1,1,1];

    instances.southwall.translate([0, 1.0, -5]);
    instances.southwall.scale([5.5, 2, 0.5]);
    instances.southwall.rotateX(3.14 / 2);
    instances.southwall.color = [0.3, 0.6, 0.8, 1];

    instances.westwall.translate([-5, 1.0, 0.0]);
    instances.westwall.scale([0.5, 2, 4.75]);
    instances.westwall.rotateZ(-3.14 / 2);
    instances.westwall.color = [0.3, 0.6, 0.8, 1];


    instances.eastwall.translate([5, 1.0, 0.0]);
    instances.eastwall.scale([0.5, 2, 4.75])
    instances.eastwall.rotateZ(3.14 / 2);
    instances.eastwall.color = [0.8, 0.6, 0.8, 1];


    instances.floor.fixNormal = true;
    instances.cube.fixNormal = true;
    instances.eastwall.fixNormal = true;
    instances.westwall.fixNormal = true;
    instances.southwall.fixNormal = true;

    var dist = 0.8;
    mat4.lookAt(viewMatrix, [10.0 * dist, 10.0 * dist, 10.0 * dist], [0, 0, 0], [0, 1, 0]);
    mat4.perspective(projectionMatrix, 65.0 * 3.14 / 180, gl.viewportWidth / gl.viewportHeight, 1, 40.0);

    mat4.multiply(cameraMatrix, projectionMatrix, viewMatrix);

    var shadowMapWidth = 1024;
    var shadowMapHeight = 1024;

    passes = {
        shadow: new VarianceShadowPass(shadowMapWidth, shadowMapHeight, false),
        diffuse: new DiffuseColorPass(gl.viewportWidth, gl.viewportHeight),
        gaussianBlur: new GaussianBlurPass(shadowMapWidth,shadowMapHeight, 10, gl.RGB, gl.FLOAT)
    };

    drawScene();
}

var sunDir = [-10, 10, -10];

function drawScene() {
    if(globalGLError)
        return;

    requestAnimationFrame(drawScene);

    vec3.transformMat4(sunDir, sunDir, mat4.rotateY(mat4.create(), mat4.create(), 0.01));

    passes.shadow.startShadow();
    mat4.lookAt(passes.shadow.viewMatrix, sunDir, [0,0,0], [0,1,0]);
    passes.shadow.uniform.uViewMatrix = passes.shadow.viewMatrix;
    passes.shadow.uniform.uDepthBias = document.getElementById("uDepthBias").value;

    for(var inst in instances) {
        passes.shadow.draw(instances[inst]);
    }

    passes.shadow.finish();


    passes.gaussianBlur.start();
    passes.gaussianBlur.ping.use();
    passes.gaussianBlur.uniform.uTexelStride = [1.0 / passes.shadow.width, 0.0];
    passes.gaussianBlur.sampler.sTexture = passes.shadow.depthTextureId;
    meshes.quad.draw();

    passes.gaussianBlur.pong.use();
    passes.gaussianBlur.uniform.uTexelStride = [0.0, 1.0 / passes.shadow.height];
    passes.gaussianBlur.sampler.sTexture = passes.gaussianBlur.ping.texture;
    meshes.quad.draw();

    passes.gaussianBlur.ping.use();
    passes.gaussianBlur.uniform.uTexelStride = [1.0 / passes.shadow.width, 0.0];
    passes.gaussianBlur.sampler.sTexture = passes.shadow.depthTextureId;
    meshes.quad.draw();

    passes.gaussianBlur.pong.use();
    passes.gaussianBlur.uniform.uTexelStride = [0.0, 1.0 / passes.shadow.height];
    passes.gaussianBlur.sampler.sTexture = passes.gaussianBlur.ping.texture;
    meshes.quad.draw();


    passes.diffuse.startDiffuse();
    passes.diffuse.uniform.uCameraMatrix = cameraMatrix;
    passes.diffuse.sampler.sVarianceTexture = passes.gaussianBlur.pong.texture;
    passes.diffuse.uniform.uMinVariance = document.getElementById("uMinVariance").value;
    passes.diffuse.uniform.uVarianceViewMatrix = passes.shadow.viewMatrix;
    passes.diffuse.uniform.uVarianceProjectionMatrix = passes.shadow.projectionMatrix;
    passes.diffuse.uniform.uLightBleed = document.getElementById("uLightBleed").value;




    var  v = vec3.create();
    vec3.normalize(v, sunDir);
    passes.diffuse.uniform.uSunDirection = v;

    for (var inst in instances) {
        passes.diffuse.draw(instances[inst]);
    }
}

</script>

</body>
</html>